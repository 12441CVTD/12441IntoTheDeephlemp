---
sidebar_position: 2
---

import { TypeLinks } from '../../src/util/type-links';
import ParamsList from '../../src/components/ParamsList';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# The Scheduler itself

üö™ The `Scheduler` is our **entry point** into the API- it's our Wardrobe, our Doors of Durin, our *Ellis Island*.

We saw some basic usage in the [Overview](./overview), but now let's really get into it.

## Scheduler opmode methods

### Scheduler.launch üöÄüöÄüöÄ

`Scheduler.launch` is what starts the entire Scheduler system, and internally hosts the loop that drives our OpModes.

<SchedulerLaunchParamList/>

<Tabs groupId="programming-language">
<TabItem value="java" label="Java">

  ```java
  @Override
  public void runOpMode() throws InterruptedException {
      instantiateListeners();

      waitForStart();

      Scheduler.launch(this);

      // or

      Scheduler.launch(this, () -> {
          // Loop code, such as PIDs
          // Run at the end of every loop
      });
  }
  ```

</TabItem>
<TabItem value="kt" label="Kotlin">

  ```kotlin
  override fun runOpMode() {
      instantiateListeners()

      waitForStart()

      Scheduler.launch(this)

      // or

      Scheduler.launch(this) {
          // Loop code, such as PIDs
          // Run at the end of every loop
      }
  }
  ```

</TabItem>
</Tabs>

### Scheduler.launchWhenReady

Equivalent to `waitForStart; Scheduler.launch(...);`

Useful for when you aren't doing anything on a loop during initialization until the game starts.

<SchedulerLaunchParamList/>

<Tabs groupId="programming-language">
<TabItem value="java" label="Java">

  ```java
  @Override
  public void runOpMode() throws InterruptedException {
      instantiateListeners();

      Scheduler.launchWhenReady(this); // Waits until the opMode starts to launch

      // or

      Scheduler.launchWhenReady(this, () -> {
          // Loop code, such as PIDs
          // Run at the end of every loop
      });
  }
  ```

</TabItem>
<TabItem value="kt" label="Kotlin">

  ```kotlin
  override fun runOpMode() {
      instantiateListeners()

      Scheduler.launchWhenReady(this) // Waits until the opMode starts to launch

      // or

      Scheduler.launchWhenReady(this) {
          // Loop code, such as PIDs
          // Run at the end of every loop
      }
  }
  ```

</TabItem>
</Tabs>

### Scheduler.beforeEach

Runs a block of code *before* all the Listeners and the `afterEach` block (the one passed directly into `Scheduler.launch` runs).

<ParamsList params={[
  {
    name: 'block',
    type: 'Runnable',
    desc: 'The block of code to run at the start of each Scheduler loop',
    typeLink: TypeLinks.LAMBDA,
  }
]}/>

<Tabs groupId="programming-language">
<TabItem value="java" label="Java">

  ```java
  @Override
  public void runOpMode() throws InterruptedException {
      Listener.always(() -> { // Listener that runs every loop, called by static method
          System.out.print(2);
      });

      Scheduler.beforeEach(() -> { // Runs at the start of every loop
          System.out.print(1);
      });

      Scheduler.launch(this, () -> { // Prints '123' every loop
          System.out.print(3);
      });
  }
  ```

</TabItem>
<TabItem value="kt" label="Kotlin">

  ```kotlin
  override fun runOpMode() {
      // Listener that runs every loop, called by static method
      Listener.always { print(2) }

      // Runs at the start of every loop
      Scheduler.beforeEach { print(1) }

      // Prints '123' every loop
      Scheduler.launch(this) { print(3) }
  }
  ```

</TabItem>
</Tabs>

### Scheduler.time ‚è∞

Utility method **for development purposes only,** which prints its loop times to the given Telemetry to roughly
benchmark performance. Does not average, only prints the raw time each cycle.

Prints in the format `Loop time (ms): <loop time>`

<ParamsList params={[
  {
    name: 'opmode',
    type: 'LinearOpMode',
    desc: 'The LinearOpMode to run the Scheduler in',
    typeLink: TypeLinks.LINEAR_OP_MODE,
  },
  {
    name: 'telemetry',
    type: 'Telemetry',
    desc: 'The Telemetry object to log the times to - NOTE: will be updated at end of loop',
    typeLink: TypeLinks.TELEMETRY,
  },
  {
    name: 'afterEach',
    type: 'Runnable',
    desc: 'An optional block of code to run every tick, after the listeners have ran',
    typeLink: TypeLinks.LAMBDA,
    defaultsTo: '() -> {}'
  }
]}/>

<Tabs groupId="programming-language">
<TabItem value="java" label="Java">

  ```java
  @Override
  public void runOpMode() throws InterruptedException {
      instantiateListeners();

      waitForStart();

      Scheduler.time(this, telemetry, () -> {
          // Loop code, such as PIDs
          // Run at the end of every loop
      });
  }
  ```

</TabItem>
<TabItem value="kt" label="Kotlin">

  ```kotlin
  override fun runOpMode() {
      instantiateListeners()

      waitForStart()

      Scheduler.time(this, telemetry) {
          // Loop code, such as PIDs
          // Run at the end of every loop
      }
  }
  ```

</TabItem>
</Tabs>

### Scheduler.reset

Removes all the subscribed [Listeners](./listeners) and resets the `beforeEach` lambda. Not entirely sure why you'd want to do this,
but hey, I'm not one to judge ¬Ø\\\_(„ÉÑ)_/¬Ø

Note that the removed Listeners will resubscribe themselves whenever a new action is subscribed to the Listener,
or if `listener.rehook` is called on them.

<Tabs groupId="programming-language">
<TabItem value="java" label="Java">

  ```java
  @Override
  public void runOpMode() throws InterruptedException {
      Scheduler.beforeEach(() -> System.out.println("Hi!"));

      Listener(() -> true).whileHigh(() -> System.out.println("I'm high!"));

      Scheduler.reset()

      // Scheduler.beforeEach == () -> {}
      // Scheduler.listeners.size == 0
  }
  ```

</TabItem>
<TabItem value="kt" label="Kotlin">

  ```kotlin
  override fun runOpMode() {
      Scheduler.beforeEach { println("Hi!") }

      Listener { true }.whileHigh { println("I'm high!") }

      Scheduler.reset()

      // Scheduler.beforeEach == () -> {}
      // Scheduler.listeners.size == 0
  }
  ```

</TabItem>
</Tabs>

## Scheduler messaging methods

A more niche functionality of the Scheduler is to directly send "messages" to invoke actions from the message receivers.

It can be triggered among classes and doesn't have to be used in an OpMode; it's versatile and can be used anywhere, even
without a running OpMode.

Just be careful that your messages don't get mixed up and accidentally intercepted/interfere with each other.

<Tabs groupId="programming-language">
<TabItem value="java" label="Java">

  ```java
  // The message can be anything you want
  // Just make sure it's comparable in some way, as it uses .equals() internally
  Scheduler.on("message", () -> {
      System.out.print("Hello,");
  });

  Scheduler.on("message", () -> {
      System.out.print(" world!");
  });

  Scheduler.emit("message"); // "Hello, world!" is printed
  Scheduler.emit("message"); // "Hello, world!" is printed again

  Object msg = new Object()
  Scheduler.emit(msg); // Nothing happens, no one is listening for it
  ```

</TabItem>
<TabItem value="kt" label="Kotlin">

  ```kotlin
  // The message can be anything you want
  // Just make sure it's comparable in some way, as it uses .equals() internally
  Scheduler.on("message") {
      print("Hello,")
  }

  Scheduler.on("message") {
      print(" world!")
  }

  Scheduler.emit("message") // "Hello, world!" is printed
  Scheduler.emit("message") // "Hello, world!" is printed again

  val msg = Any()
  Scheduler.emit(msg) // Nothing happens, no one is listening for it
  ```

</TabItem>
</Tabs>

### Scheduler.emit

Broadcasts a message for anyone to receive with [Scheduler.emit](#scheduleremit).

<ParamsList params={[
  {
    name: 'message',
    type: 'Any',
    desc: 'The "message" to send, can be literally anything (doesn\'t have to be of any significant, just that both the sender and the receiver have to know it). NOTE: this uses .equals() to compare messages, so make sure the message is comparable in some way.',
  }
]}/>

### Scheduler.on

Registers a message receiver, which will be called whenever a message is sent with [Scheduler.emit](#scheduleremit).

<ParamsList params={[
  {
    name: 'message',
    type: 'Any',
    desc: 'The "message" to listen for, can be literally anything (doesn\'t have to be of any significant, just that both the sender and the receiver have to know it). NOTE: this uses .equals() to compare messages, so make sure the message is comparable in some way.',
  },
  {
    name: 'block',
    type: 'Runnable',
    desc: 'The block of code to run when the message is received',
    typeLink: TypeLinks.LAMBDA,
  }
]}/>

export function SchedulerLaunchParamList() {
  return (
    <ParamsList params={[
      {
        name: 'opmode',
        type: 'LinearOpMode',
        desc: 'The LinearOpMode to run the Scheduler in',
        typeLink: TypeLinks.LINEAR_OP_MODE,
      },
      {
        name: 'afterEach',
        type: 'Runnable',
        desc: 'An optional block of code to run after every cycle, after the listeners have ran',
        typeLink: TypeLinks.LAMBDA,
        defaultsTo: '() -> {}',
      }
    ]}/>
  )
}

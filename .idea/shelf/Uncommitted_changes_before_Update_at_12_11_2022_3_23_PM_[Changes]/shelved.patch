Index: Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseOpMode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.team6220_PowerPlay;\r\n\r\nimport com.qualcomm.hardware.bosch.BNO055IMU;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\r\n\r\npublic abstract class BaseOpMode extends LinearOpMode {\r\n\r\n    // motors\r\n    public static DcMotorEx motorFL;\r\n    public static DcMotorEx motorFR;\r\n    public static DcMotorEx motorBL;\r\n    public static DcMotorEx motorBR;\r\n\r\n    public static DcMotorEx motorTurntable;\r\n    public static DcMotorEx motorLeftSlides;\r\n    public static DcMotorEx motorRightSlides;\r\n\r\n    // servos\r\n    public static Servo servoGrabber;\r\n\r\n    // IMU\r\n    public BNO055IMU imu;\r\n    public Orientation IMUOriginalAngles; // original angle reading from imu that will be used to find unwanted angle offset during drive\r\n\r\n    // flag to say whether we should disable the correction system\r\n    private boolean turnFlag = false;\r\n\r\n    // initializes the motors, servos, and IMUs\r\n    public void initialize() {\r\n        // motors\r\n        motorFL = (DcMotorEx) hardwareMap.get(DcMotor.class, \"motorFL\");\r\n        motorFR = (DcMotorEx) hardwareMap.get(DcMotor.class, \"motorFR\");\r\n        motorBL = (DcMotorEx) hardwareMap.get(DcMotor.class, \"motorBL\");\r\n        motorBR = (DcMotorEx) hardwareMap.get(DcMotor.class, \"motorBR\");\r\n        motorTurntable = (DcMotorEx) hardwareMap.get(DcMotor.class, \"motorTurntable\");\r\n        motorLeftSlides = (DcMotorEx) hardwareMap.get(DcMotor.class, \"motorLVSlides\");\r\n        motorRightSlides = (DcMotorEx) hardwareMap.get(DcMotor.class, \"motorRVSlides\");\r\n\r\n        motorFL.setDirection(DcMotorEx.Direction.FORWARD);\r\n        motorFR.setDirection(DcMotorEx.Direction.REVERSE);\r\n        motorBL.setDirection(DcMotorEx.Direction.FORWARD);\r\n        motorBR.setDirection(DcMotorEx.Direction.REVERSE);\r\n        motorLeftSlides.setDirection(DcMotorEx.Direction.FORWARD);\r\n        motorRightSlides.setDirection(DcMotorEx.Direction.FORWARD);\r\n        motorTurntable.setDirection(DcMotorEx.Direction.FORWARD);\r\n\r\n        motorFL.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);\r\n        motorFR.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);\r\n        motorBL.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);\r\n        motorBR.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n        motorFL.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);\r\n        motorFR.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);\r\n        motorBL.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);\r\n        motorBR.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);\r\n\r\n        motorTurntable.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);\r\n        motorLeftSlides.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);\r\n        motorRightSlides.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n        motorFL.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);\r\n        motorFR.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);\r\n        motorBL.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);\r\n        motorBR.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);\r\n\r\n        motorTurntable.setTargetPosition(0);\r\n        motorTurntable.setMode(DcMotorEx.RunMode.RUN_TO_POSITION);\r\n        motorTurntable.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);\r\n\r\n        motorLeftSlides.setMode(DcMotorEx.RunMode.RUN_WITHOUT_ENCODER);\r\n        motorRightSlides.setMode(DcMotorEx.RunMode.RUN_WITHOUT_ENCODER);\r\n        motorLeftSlides.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);\r\n        motorRightSlides.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);\r\n\r\n        // servos\r\n        servoGrabber = hardwareMap.servo.get(\"servoGrabber\");\r\n\r\n        // initialize IMU\r\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\r\n        parameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\r\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\r\n        imu.initialize(parameters);\r\n\r\n        servoGrabber.setPosition(Constants.GRABBER_INITIALIZE_POSITION);\r\n    }\r\n\r\n    public void driveWithIMU(double xPower, double yPower, double tPower) {\r\n        // read imu when turning (when t != 0)\r\n        boolean isTurning = (tPower != 0);\r\n\r\n        if (isTurning || turnFlag) {\r\n            IMUOriginalAngles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES); // set original angle\r\n\r\n            if (!turnFlag) {\r\n                turnFlag = true;\r\n            }\r\n\r\n        // otherwise read imu for correction\r\n        } else {\r\n            // obtain the current angle's error from the original angle\r\n            Orientation currentAngle = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n            double angleError = IMUOriginalAngles.firstAngle - currentAngle.firstAngle;\r\n\r\n            // flip to inverse of angles above 180 / below -180 (to prevent infinity-rotate bug)\r\n            // to make sure to use the shorter angle\r\n            if (angleError > 180.0) {\r\n                angleError -= 360.0;\r\n            } else if (angleError < -180.0) {\r\n                angleError += 360.0;\r\n            }\r\n\r\n            // apply a constant to turn the angle into a turn speed\r\n            tPower = -Constants.CORRECTION_CONSTANT * angleError;\r\n        }\r\n\r\n        // if the rotation rate is low, then that means all the momentum has left the robot's turning and can therefore turn the correction back on\r\n        if (Math.abs(imu.getAngularVelocity().zRotationRate) < 5) {\r\n            turnFlag = false;\r\n        }\r\n\r\n        // calculate speed and direction of each individual motor and set power of motors to speed\r\n        motorFL.setPower(-yPower + xPower + tPower);\r\n        motorFR.setPower(-yPower - xPower - tPower);\r\n        motorBL.setPower(-yPower - xPower + tPower);\r\n        motorBR.setPower(-yPower + xPower - tPower);\r\n    }\r\n\r\n    /**\r\n     * this method will allow the grabber to open or close given a boolean input\r\n     * @param position the position of the grabber\r\n     */\r\n    public void driveGrabber(double position) {\r\n        servoGrabber.setPosition(position);\r\n    }\r\n\r\n    /**\r\n     * this method will allow the slides to move upwards and downwards given a specified target position\r\n     * @param targetPosition target position for vertical slides motors in ticks\r\n     */\r\n    public void driveSlides(int targetPosition) {\r\n        int error = targetPosition - motorLeftSlides.getCurrentPosition();\r\n\r\n        // slides not yet at target position\r\n        if (Math.abs(error) > 25) {\r\n\r\n            // slides going down\r\n            if (error < 0) {\r\n\r\n                // slides above low junction\r\n                if (motorLeftSlides.getCurrentPosition() > Constants.SLIDE_LOW) {\r\n                    motorLeftSlides.setPower(-0.05);\r\n                    motorRightSlides.setPower(-0.05);\r\n\r\n                // slides below low junction\r\n                } else {\r\n                    motorLeftSlides.setPower(-1);\r\n                    motorRightSlides.setPower(-1);\r\n                }\r\n\r\n            // slides going up\r\n            } else {\r\n                motorLeftSlides.setPower(0.75);\r\n                motorRightSlides.setPower(0.75);\r\n            }\r\n\r\n        // slides at target position so holding position\r\n        } else {\r\n            motorLeftSlides.setPower(0.1);\r\n            motorRightSlides.setPower(0.1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * this method will allow the turntable to turn clockwise or counterclockwise given a specified power and position\r\n     * @param position target position of turntable motor in ticks\r\n     */\r\n    public void driveTurntable(int position) {\r\n        motorTurntable.setTargetPosition(position);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseOpMode.java b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseOpMode.java
--- a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseOpMode.java	(revision df447b422d5a0fafd887f6f6c92c3c45bafab422)
+++ b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseOpMode.java	(date 1670800962554)
@@ -4,6 +4,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.hardware.DcMotor;
 import com.qualcomm.robotcore.hardware.DcMotorEx;
+import com.qualcomm.robotcore.hardware.DcMotorSimple;
 import com.qualcomm.robotcore.hardware.Servo;
 
 import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
@@ -48,35 +49,35 @@
         motorFR.setDirection(DcMotorEx.Direction.REVERSE);
         motorBL.setDirection(DcMotorEx.Direction.FORWARD);
         motorBR.setDirection(DcMotorEx.Direction.REVERSE);
-        motorLeftSlides.setDirection(DcMotorEx.Direction.FORWARD);
-        motorRightSlides.setDirection(DcMotorEx.Direction.FORWARD);
-        motorTurntable.setDirection(DcMotorEx.Direction.FORWARD);
 
         motorFL.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
         motorFR.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
         motorBL.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
         motorBR.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
 
+        motorFL.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
+        motorFR.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
+        motorBL.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
+        motorBR.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
+
         motorFL.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);
         motorFR.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);
         motorBL.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);
         motorBR.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);
 
+        motorTurntable.setDirection(DcMotorEx.Direction.FORWARD);
+        motorLeftSlides.setDirection(DcMotorEx.Direction.FORWARD);
+        motorRightSlides.setDirection(DcMotorEx.Direction.REVERSE);
+
         motorTurntable.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
         motorLeftSlides.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
         motorRightSlides.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
 
-        motorFL.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
-        motorFR.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
-        motorBL.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
-        motorBR.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
-
-        motorTurntable.setTargetPosition(0);
-        motorTurntable.setMode(DcMotorEx.RunMode.RUN_TO_POSITION);
-        motorTurntable.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);
-
+        motorTurntable.setMode(DcMotorEx.RunMode.RUN_WITHOUT_ENCODER);
         motorLeftSlides.setMode(DcMotorEx.RunMode.RUN_WITHOUT_ENCODER);
         motorRightSlides.setMode(DcMotorEx.RunMode.RUN_WITHOUT_ENCODER);
+
+        motorTurntable.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);
         motorLeftSlides.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);
         motorRightSlides.setZeroPowerBehavior(DcMotorEx.ZeroPowerBehavior.BRAKE);
 
@@ -142,47 +143,36 @@
     }
 
     /**
-     * this method will allow the slides to move upwards and downwards given a specified target position
-     * @param targetPosition target position for vertical slides motors in ticks
+     * this method will allow the slides to move given a target position
+     * @param targetPosition target position for slides motors in ticks
      */
     public void driveSlides(int targetPosition) {
         int error = targetPosition - motorLeftSlides.getCurrentPosition();
+        double motorPower = Math.max(error * 0.005, 0.2);
 
         // slides not yet at target position
-        if (Math.abs(error) > 25) {
-
-            // slides going down
+        if (Math.abs(error) > 20) {
+            // slides going down - constant speed
             if (error < 0) {
-
-                // slides above low junction
-                if (motorLeftSlides.getCurrentPosition() > Constants.SLIDE_LOW) {
-                    motorLeftSlides.setPower(-0.05);
-                    motorRightSlides.setPower(-0.05);
-
-                // slides below low junction
-                } else {
-                    motorLeftSlides.setPower(-1);
-                    motorRightSlides.setPower(-1);
-                }
-
-            // slides going up
-            } else {
-                motorLeftSlides.setPower(0.75);
-                motorRightSlides.setPower(0.75);
-            }
-
-        // slides at target position so holding position
+                motorLeftSlides.setPower(-0.75);
+                motorRightSlides.setPower(-0.75);
+            // slides going up - proportional control
+            } else {
+                motorLeftSlides.setPower(motorPower);
+                motorRightSlides.setPower(motorPower);
+            }
+        // slides at target position
         } else {
-            motorLeftSlides.setPower(0.1);
-            motorRightSlides.setPower(0.1);
+            motorLeftSlides.setPower(0.05);
+            motorRightSlides.setPower(0.05);
         }
     }
 
     /**
-     * this method will allow the turntable to turn clockwise or counterclockwise given a specified power and position
-     * @param position target position of turntable motor in ticks
+     * this method will allow the turntable to turn given a target position
+     * @param targetPosition target position for turntable motor in ticks
      */
-    public void driveTurntable(int position) {
-        motorTurntable.setTargetPosition(position);
+    public void driveTurntable(double targetPosition) {
+
     }
 }
Index: Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/testclasses/TeleOpTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.team6220_PowerPlay.testclasses;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\r\nimport org.firstinspires.ftc.team6220_PowerPlay.BaseTeleOp;\r\n\r\n@Disabled\r\n@TeleOp(name = \"TeleOpTest\", group = \"Test\")\r\npublic class TeleOpTest extends BaseTeleOp {\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        double p = 10.0, i = 3.0, d = 0.0, f = 0.0;\r\n\r\n        initialize();\r\n        waitForStart();\r\n\r\n        // get angle after startup to prevent jitter on startup\r\n        IMUOriginalAngles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        while (opModeIsActive()) {\r\n            driveChassisWithController();\r\n\r\n            if (gamepad1.a) {\r\n                if (gamepad1.dpad_up) {\r\n                    p++;\r\n                } else if (gamepad1.dpad_down) {\r\n                    p--;\r\n                }\r\n\r\n            } else if (gamepad1.x) {\r\n                if (gamepad1.dpad_up) {\r\n                    i++;\r\n                } else if (gamepad1.dpad_down) {\r\n                    i--;\r\n                }\r\n\r\n            } else if (gamepad1.y) {\r\n                if (gamepad1.dpad_up) {\r\n                    d++;\r\n                } else if (gamepad1.dpad_down) {\r\n                    d--;\r\n                }\r\n\r\n            } else if (gamepad1.b) {\r\n                if (gamepad1.dpad_up) {\r\n                    f++;\r\n                } else if (gamepad1.dpad_down) {\r\n                    f--;\r\n                }\r\n            }\r\n\r\n            motorFL.setVelocityPIDFCoefficients(p, i, d, f);\r\n            motorFR.setVelocityPIDFCoefficients(p, i, d, f);\r\n            motorBL.setVelocityPIDFCoefficients(p, i, d, f);\r\n            motorBR.setVelocityPIDFCoefficients(p, i, d, f);\r\n\r\n            telemetry.addData(\"p\", p);\r\n            telemetry.addData(\"i\", i);\r\n            telemetry.addData(\"d\", d);\r\n            telemetry.addData(\"f\", f);\r\n            telemetry.update();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/testclasses/TeleOpTest.java b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/testclasses/TeleOpTest.java
--- a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/testclasses/TeleOpTest.java	(revision df447b422d5a0fafd887f6f6c92c3c45bafab422)
+++ b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/testclasses/TeleOpTest.java	(date 1670800962591)
@@ -14,56 +14,12 @@
 
     @Override
     public void runOpMode() {
-        double p = 10.0, i = 3.0, d = 0.0, f = 0.0;
-
         initialize();
         waitForStart();
 
-        // get angle after startup to prevent jitter on startup
-        IMUOriginalAngles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);
-
         while (opModeIsActive()) {
-            driveChassisWithController();
-
-            if (gamepad1.a) {
-                if (gamepad1.dpad_up) {
-                    p++;
-                } else if (gamepad1.dpad_down) {
-                    p--;
-                }
-
-            } else if (gamepad1.x) {
-                if (gamepad1.dpad_up) {
-                    i++;
-                } else if (gamepad1.dpad_down) {
-                    i--;
-                }
-
-            } else if (gamepad1.y) {
-                if (gamepad1.dpad_up) {
-                    d++;
-                } else if (gamepad1.dpad_down) {
-                    d--;
-                }
-
-            } else if (gamepad1.b) {
-                if (gamepad1.dpad_up) {
-                    f++;
-                } else if (gamepad1.dpad_down) {
-                    f--;
-                }
-            }
-
-            motorFL.setVelocityPIDFCoefficients(p, i, d, f);
-            motorFR.setVelocityPIDFCoefficients(p, i, d, f);
-            motorBL.setVelocityPIDFCoefficients(p, i, d, f);
-            motorBR.setVelocityPIDFCoefficients(p, i, d, f);
-
-            telemetry.addData("p", p);
-            telemetry.addData("i", i);
-            telemetry.addData("d", d);
-            telemetry.addData("f", f);
-            telemetry.update();
+            motorLeftSlides.setPower(-gamepad2.left_stick_y);
+            motorRightSlides.setPower(-gamepad2.left_stick_y);
         }
     }
 }
Index: Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/Constants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.team6220_PowerPlay;\r\n\r\npublic class Constants {\r\n    public static final double INCHES_PER_METER = 100 / 2.54;\r\n\r\n    public static final double CORRECTION_CONSTANT = 1 / 45.0; // constant for converting angle error to motor speed\r\n\r\n    public static final int SLIDE_HIGH = 2750;\r\n    public static final int SLIDE_MEDIUM = 1950;\r\n    public static final int SLIDE_LOW = 1150;\r\n    public static final int SLIDE_BOTTOM = 0;\r\n\r\n    public static final double DRIVE_SPEED_MULTIPLIER = 0.5;\r\n    public static final int DRIVE_DEADZONE_DEGREES = 45;\r\n\r\n    public static final double GRABBER_INITIALIZE_POSITION = 0.7;\r\n    public static final double GRABBER_OPEN_POSITION = 0.35;\r\n    public static final double GRABBER_CLOSE_POSITION = 0.0;\r\n\r\n    public static final double WHEEL_CIRCUMFERENCE = 96 / 25.4 * Math.PI;\r\n    public static final double DRIVE_MOTOR_TICKS_TO_INCHES = WHEEL_CIRCUMFERENCE * 2 / 537.6;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/Constants.java b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/Constants.java
--- a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/Constants.java	(revision df447b422d5a0fafd887f6f6c92c3c45bafab422)
+++ b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/Constants.java	(date 1670800962575)
@@ -5,16 +5,20 @@
 
     public static final double CORRECTION_CONSTANT = 1 / 45.0; // constant for converting angle error to motor speed
 
-    public static final int SLIDE_HIGH = 2750;
-    public static final int SLIDE_MEDIUM = 1950;
-    public static final int SLIDE_LOW = 1150;
+    public static final int SLIDE_TOP = 3900;
+    public static final int SLIDE_HIGH = 3750;
+    public static final int SLIDE_MEDIUM = 2750;
+    public static final int SLIDE_LOW = 1650;
     public static final int SLIDE_BOTTOM = 0;
 
+    public static final int TURNTABLE_COUNTERCLOCKWISE_STOP = -287;
+    public static final int TURNTABLE_CLOCKWISE_STOP = 287;
+
     public static final double DRIVE_SPEED_MULTIPLIER = 0.5;
     public static final int DRIVE_DEADZONE_DEGREES = 45;
 
     public static final double GRABBER_INITIALIZE_POSITION = 0.7;
-    public static final double GRABBER_OPEN_POSITION = 0.35;
+    public static final double GRABBER_OPEN_POSITION = 0.25;
     public static final double GRABBER_CLOSE_POSITION = 0.0;
 
     public static final double WHEEL_CIRCUMFERENCE = 96 / 25.4 * Math.PI;
Index: Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/competition/TeleOpCompetition.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.team6220_PowerPlay.competition;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\r\nimport org.firstinspires.ftc.team6220_PowerPlay.BaseTeleOp;\r\n\r\n@TeleOp(name = \"TeleOpCompetition\", group = \"Competition\")\r\npublic class TeleOpCompetition extends BaseTeleOp {\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        initialize();\r\n        waitForStart();\r\n\r\n        driveTurntableWithController();\r\n\r\n        // get angle after startup to prevent jitter on startup\r\n        IMUOriginalAngles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        while (opModeIsActive()) {\r\n            driveChassisWithController();\r\n            driveGrabberWithController();\r\n            driveSlidesWithController();\r\n\r\n            telemetry.addData(\"slide\", motorLeftSlides.getCurrentPosition());\r\n            telemetry.update();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/competition/TeleOpCompetition.java b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/competition/TeleOpCompetition.java
--- a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/competition/TeleOpCompetition.java	(revision df447b422d5a0fafd887f6f6c92c3c45bafab422)
+++ b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/competition/TeleOpCompetition.java	(date 1670800962581)
@@ -13,10 +13,9 @@
     @Override
     public void runOpMode() {
         initialize();
+        sleep(3000);
         waitForStart();
 
-        driveTurntableWithController();
-
         // get angle after startup to prevent jitter on startup
         IMUOriginalAngles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);
 
Index: Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseTeleOp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.team6220_PowerPlay;\r\n\r\npublic abstract class BaseTeleOp extends BaseOpMode {\r\n    double xPower;\r\n    double yPower;\r\n    double tPower;\r\n\r\n    public void driveChassisWithController() {\r\n        xPower = gamepad1.left_stick_x * Constants.DRIVE_SPEED_MULTIPLIER * (1 - gamepad1.left_trigger * 0.5);\r\n        yPower = gamepad1.left_stick_y * Constants.DRIVE_SPEED_MULTIPLIER * (1 - gamepad1.left_trigger * 0.5);\r\n        tPower = gamepad1.right_stick_x * Constants.DRIVE_SPEED_MULTIPLIER * (1 - gamepad1.left_trigger * 0.5);\r\n\r\n        // case for driving the robot left and right\r\n        if (Math.abs(Math.toDegrees(Math.atan(gamepad1.left_stick_y / gamepad1.left_stick_x))) < Constants.DRIVE_DEADZONE_DEGREES) {\r\n            driveWithIMU(xPower, 0.0, tPower);\r\n\r\n        // case for driving the robot forwards and backwards\r\n        } else if (Math.abs(Math.toDegrees(Math.atan(gamepad1.left_stick_y / gamepad1.left_stick_x))) > Constants.DRIVE_DEADZONE_DEGREES) {\r\n            driveWithIMU(0.0, yPower, tPower);\r\n\r\n        // case for if the deadzone limits are passed, the robot drives normally\r\n        } else {\r\n            driveWithIMU(xPower, yPower, tPower);\r\n        }\r\n    }\r\n\r\n    public void driveGrabberWithController() {\r\n        if (gamepad2.a) {\r\n            driveGrabber(Constants.GRABBER_CLOSE_POSITION);\r\n        } else if (gamepad2.x) {\r\n            driveGrabber(Constants.GRABBER_OPEN_POSITION);\r\n        }\r\n    }\r\n\r\n    public void driveSlidesWithController() {\r\n        if (-gamepad2.left_stick_y < 0 && motorLeftSlides.getCurrentPosition() > Constants.SLIDE_LOW) {\r\n            motorLeftSlides.setPower(-gamepad2.left_stick_y * 0.05);\r\n            motorRightSlides.setPower(-gamepad2.left_stick_y * 0.05);\r\n        } else if (-gamepad2.left_stick_y < 0 && motorLeftSlides.getCurrentPosition() <= Constants.SLIDE_LOW) {\r\n            motorLeftSlides.setPower(-gamepad2.left_stick_y);\r\n            motorRightSlides.setPower(-gamepad2.left_stick_y);\r\n        } else {\r\n            motorLeftSlides.setPower(-gamepad2.left_stick_y * 0.75);\r\n            motorRightSlides.setPower(-gamepad2.left_stick_y * 0.75);\r\n        }\r\n\r\n        if (motorLeftSlides.getCurrentPosition() < Constants.SLIDE_BOTTOM) {\r\n            motorLeftSlides.setPower(0.5);\r\n            motorRightSlides.setPower(0.5);\r\n        }\r\n    }\r\n\r\n    public void driveTurntableWithController() {\r\n        driveTurntable(0);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseTeleOp.java b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseTeleOp.java
--- a/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseTeleOp.java	(revision df447b422d5a0fafd887f6f6c92c3c45bafab422)
+++ b/Team6220_PowerPlay/src/main/java/org/firstinspires/ftc/team6220_PowerPlay/BaseTeleOp.java	(date 1670800962565)
@@ -5,6 +5,10 @@
     double yPower;
     double tPower;
 
+    int slideTargetPosition = 0;
+    int junction = 0;
+    int[] junctions = {0, 0};
+
     public void driveChassisWithController() {
         xPower = gamepad1.left_stick_x * Constants.DRIVE_SPEED_MULTIPLIER * (1 - gamepad1.left_trigger * 0.5);
         yPower = gamepad1.left_stick_y * Constants.DRIVE_SPEED_MULTIPLIER * (1 - gamepad1.left_trigger * 0.5);
@@ -25,32 +29,73 @@
     }
 
     public void driveGrabberWithController() {
-        if (gamepad2.a) {
+        if (gamepad2.x) {
             driveGrabber(Constants.GRABBER_CLOSE_POSITION);
-        } else if (gamepad2.x) {
+        } else if (gamepad2.a) {
             driveGrabber(Constants.GRABBER_OPEN_POSITION);
+        } else if (gamepad2.b) {
+            driveGrabber(Constants.GRABBER_INITIALIZE_POSITION);
         }
     }
 
     public void driveSlidesWithController() {
-        if (-gamepad2.left_stick_y < 0 && motorLeftSlides.getCurrentPosition() > Constants.SLIDE_LOW) {
-            motorLeftSlides.setPower(-gamepad2.left_stick_y * 0.05);
-            motorRightSlides.setPower(-gamepad2.left_stick_y * 0.05);
-        } else if (-gamepad2.left_stick_y < 0 && motorLeftSlides.getCurrentPosition() <= Constants.SLIDE_LOW) {
-            motorLeftSlides.setPower(-gamepad2.left_stick_y);
-            motorRightSlides.setPower(-gamepad2.left_stick_y);
-        } else {
-            motorLeftSlides.setPower(-gamepad2.left_stick_y * 0.75);
-            motorRightSlides.setPower(-gamepad2.left_stick_y * 0.75);
-        }
+        slideTargetPosition += (int) (-gamepad2.left_stick_y * 25);
+
+        if (gamepad2.right_bumper && junctions[0] == junctions[1]) {
+            junction++;
+
+            if (junction >= 3) {
+                junction = 3;
+            }
+
+            switch (junction) {
+                case 1:
+                    slideTargetPosition = Constants.SLIDE_LOW;
+                    break;
+                case 2:
+                    slideTargetPosition = Constants.SLIDE_MEDIUM;
+                    break;
+                case 3:
+                    slideTargetPosition = Constants.SLIDE_HIGH;
+                    break;
+            }
+        } else if (gamepad2.left_bumper && junctions[0] == junctions[1]) {
+            junction--;
 
-        if (motorLeftSlides.getCurrentPosition() < Constants.SLIDE_BOTTOM) {
-            motorLeftSlides.setPower(0.5);
-            motorRightSlides.setPower(0.5);
+            if (junction <= 0) {
+                junction = 0;
+            }
+
+            switch (junction) {
+                case 0:
+                    slideTargetPosition = Constants.SLIDE_BOTTOM;
+                    break;
+                case 1:
+                    slideTargetPosition = Constants.SLIDE_LOW;
+                    break;
+                case 2:
+                    slideTargetPosition = Constants.SLIDE_MEDIUM;
+                    break;
+            }
         }
+
+        // don't let target position go below slide bottom position
+        if (slideTargetPosition <= Constants.SLIDE_BOTTOM) {
+            slideTargetPosition = Constants.SLIDE_BOTTOM;
+        // don't let target position go above slide top position
+        } else if (slideTargetPosition >= Constants.SLIDE_TOP) {
+            slideTargetPosition = Constants.SLIDE_TOP;
+        }
+
+        driveSlides(slideTargetPosition);
+
+        if (!gamepad2.left_bumper && !gamepad2.right_bumper) {
+            junctions[0] = junctions[1];
+        }
+
+        junctions[1] = junction;
     }
 
     public void driveTurntableWithController() {
-        driveTurntable(0);
     }
 }
